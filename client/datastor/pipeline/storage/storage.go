/*
 * Copyright (C) 2017-2018 GIG Technology NV and Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package storage

import (
	"errors"
	"runtime"

	"github.com/threefoldtech/0-stor/client/metastor/metatypes"
)

var (
	// DefaultJobCount is the default job count used if the API
	// was created with a job count of 0.
	DefaultJobCount = runtime.NumCPU() * 2
)

// Errors that can be returned by a storage.
var (
	ErrUnexpectedObjectCount = errors.New("unexpected object count")
	ErrShardsUnavailable     = errors.New("(too many?) shards are unavailable")
	ErrNotSupported          = errors.New("method is not supported")
	ErrInvalidDataSize       = errors.New("returned object has invalid data size")
)

// ChunkStorage is used store a chunk on a given cluster.
type ChunkStorage interface {
	// WriteChunk writes a data chunk as one or multiple objects to a storage,
	// returning the generated chunk's config used to store it.
	//
	// Remember to store the returned config,
	// as you'll need it in order to read the chunk back back.
	WriteChunk(data []byte) (*ChunkConfig, error)

	// ReadChunk reads the chunk's objects from a storage,
	// using the chunk config generated while writing the object, previously.
	ReadChunk(cfg ChunkConfig) ([]byte, error)

	// CheckChunk checks if a chunk is in a valid condition.
	//
	// The fast parameter can be given in case you want to do a fast check only,
	// which means it will return as soon as all the needed objects
	// are found to be in a valid condition,
	// ignoring the possibility that it could even be in excellent condition.
	//
	// An error can be returned in case the given chunk config
	// is not compatible with the used storage.
	// Meaning the chunk cannot be read, written or repaired.
	CheckChunk(cfg ChunkConfig, fast bool) (CheckStatus, error)

	// RepairChunk will try to repair a chunk, already stored within the Storage.
	// If the chunk could be repaired, the updated chunk config will be returned and
	// indicate the current objects are stored/used for this chunk.
	RepairChunk(cfg ChunkConfig) (*ChunkConfig, error)

	// DeleteChunk will delete a chunk, previously stored within the Storage.
	// If the chunk was written using a different type of ChunkStorage,
	// it might not be possible to delete that chunk.
	// When an error is returned it should be assumed the chunk wasn't deleted,
	// if no error is returned, however, it can be assumed that the chunk was deleted.
	DeleteChunk(cfg ChunkConfig) error

	// Close any open resources.
	Close() error
}

// ChunkConfig is a configuration type,
// generated by a ChunkStorage when writing a chunk to that storage.
// The callee can use this config at a later time in order to read the chunk once again.
type ChunkConfig struct {
	Size    int64
	Objects []metatypes.Object
}

// CheckStatus is the status returned when checking the
// state of a chunk using the `(ChunkStorage).Check` method,
// and indicates whether a chunk can, should or shouldn't be repaired.
type CheckStatus uint8

const (
	// CheckStatusInvalid indicates that the chunk is invalid as it is,
	// and should be repaired if it is needed for usage.
	CheckStatusInvalid CheckStatus = iota

	// CheckStatusValid indicates that the chunk is valid,
	// but it can be repaired to bring it (back) to an optimal state.
	CheckStatusValid

	// CheckStatusOptimal indicates that a chunk is valid in the most optimal way,
	// and no further action (such as repairing) is needed in any way.
	//
	// Repairing a chunk in this state is basically a waste of resources.
	CheckStatusOptimal
)

// String implements Stringer.String
func (status CheckStatus) String() string {
	return checkStatusStringMapping[status]
}

const checkStatusString = "invalidoptimal"

var checkStatusStringMapping = map[CheckStatus]string{
	CheckStatusInvalid: checkStatusString[:7],
	CheckStatusValid:   checkStatusString[2:7],
	CheckStatusOptimal: checkStatusString[7:],
}
